global !p
types = {
	'b': 'bool',
	'c': 'char',
	'i': 'int',
	'll': 'long long',
	's': 'string',
}

def getParams(s):
	cur = ""
	depth = 0
	valid = True
	params = []
	for c in s:
		if (c == '<'):
			depth += 1
		elif (c == '>'):
			depth -= 1
		elif (c == ' '):
			cur = ""
		elif c == ',' and depth == 0:
			params.append(cur)
			cur = ""
		else:
			cur += c
	if cur and valid:
		params.append(cur)
	return params

def getDocstring(snip):
	anonSnippetBody = ""
	parameters = getParams(snip.buffer[snip.line].strip())
	for p in parameters:
		anonSnippetBody += p + "\n"
	snip.expand_anon(f"$4 $5 $6")
	# for i in range(len(parameters)):
	# 	anonSnippetBody += "    @param " + parameters[i] + ": ${" + str(i + 4) + "}\n"
	# anonSnippetBody += "    @return " + "${" + str(len(parameters) + 1) + ":Return description}"
	# snip.expand_anon(anonSnippetBody)
endglobal

snippet inc "include" b
#include <${1:iostream}>
endsnippet

snippet "for([^ ]+) " "auto for loop" brA
for (auto& `!p snip.rv = match.group(1)` : ${1:arr}) {
	$0
}
endsnippet

# snippet "for " "for loop" brA
# for (int ${1:i} = ${2:0}; $1 < ${3:sz}; $1++) {
# 	$0
# }
# endsnippet

snippet "vec([bcis]|ll)" "vector" wrA
vector<`!p snip.rv = types[match.group(1)]`>$0
endsnippet

snippet "vec " "general vector" wrA
vector<${1:type}>$0
endsnippet

snippet "(u?)map([bcis]|ll)([bcis]|ll)" "map" wrA
`!p
if (match.group(1) != ""):
	snip.rv = "unordered_"
snip.rv += "map<" + types[match.group(2)] + ", " + types[match.group(3)] + ">"
`$0
endsnippet

snippet "(u?)map " "general map" brA
`!p
if (match.group(1) != ""):
	snip.rv = "unordered_"
`map<${2:type}, ${3:type}>$0
endsnippet

snippet "(u?)set([bcis]|ll)" "set" wrA
`!p
if (match.group(1) != ""):
	snip.rv = "unordered_"
snip.rv += "set<" + types[match.group(2)] + ">"
`$0
endsnippet

snippet "(u?)set " "general set" wrA
`!p
if (match.group(1) != ""):
	snip.rv = "unordered_"
`set<${2:type}>$0
endsnippet

snippet "pair([bcis]|ll)([bcis]|ll)" "pair" wrA
`!p
snip.rv = "pair<" + types[match.group(1)] + ", " + types[match.group(2)] + ">"
`$0
endsnippet

snippet "pair " "general pair" wrA
pair<${1:type}, ${2:type}>$0
endsnippet

snippet "stk([bcis]|ll)" "stack" wrA
stack<`!p snip.rv = types[match.group(1)]`>$0
endsnippet

snippet "stk " "general stack" wrA
stack<${1:type}>$0
endsnippet

# snippet "fn([bcis]|ll) " "function" brA
# `!p snip.rv = types[match.group(1)]` ${1:functionName}($2) {
# 	$0
# }
# endsnippet

# /**
# 	${4:General description}
# */
#`!p snip.rv = t[3]`
post_jump "if snip.tabstop == 4: getDocstring(snip)"
snippet "fn " "general function" brA
${1:int} ${2:main}($3) {
	`!p snip.rv = "int x, string y, vector<pair<int, int>> vp"`
	$4
}
endsnippet

snippet sort "sort function" bA
sort(begin(${1:arr}), end($1));
endsnippet

snippet reverse "reverse function" bA
reverse(begin(${1:arr}), end($1));
endsnippet

snippet class "class creator" b
class ${1:className} {
public:
	$1();
	~$1();
private:
};
endsnippet

snippet setup "setup" bA
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;

int main() {
	int num;
	cin >> num;
	$0
}
endsnippet

snippet getline "getline" bA
getline(cin, ${1:arr});
endsnippet

snippet "incl(.+)" "include guard" br
`!p
guard = match.group(1)
transformed_guard = ""
for c in guard:
	if (c == ' '):
		transformed_guard += '_'
	else:
		transformed_guard += c.upper()
snip.rv = "#ifndef "
snip.rv += transformed_guard + '\n'
snip.rv += "#define "
snip.rv += transformed_guard + '\n'
`
$0

#endif
endsnippet

snippet ignore "cin ignore" bA
cin.ignore(10000, '\n');
$0
endsnippet
